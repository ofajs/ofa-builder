<template page>
  <style>
    .container {
      display: flex;
      align-items: center;
      flex-direction: column;
    }
  </style>
  <div class="container">
    <h2>接下来将对 组件 / 页面 / js文件 进行压缩混淆</h2>
    <p>请选择要文件的处理方式</p>
    <div>{{tips}}</div>
    <div>
      <p-button on:click="toSameDir('min')">源文件旁生成min文件</p-button>
      <p-button on:click="toSameDir('cover')">直接覆盖</p-button>
      <!-- <p-button on:click="toDist" attr:disabled="doing ? '' : null"
        >项目导出到dist目录</p-button
      >
      <p-button on:click="toZip" attr:disabled="doing ? '' : null"
        >项目导出为zip文件</p-button
      > -->
    </div>
    <x-if :value="ok">
      <h3>转换完成</h3>
      <x-if :value="errors.length">
        以下文件转换失败，请检查文件是否出错。
        <ul>
          <x-fill :value="errors"> <li>{{$data}}</li> </x-fill>
        </ul>
      </x-if>
    </x-if>
  </div>
  <script>
    export default async ({ load }) => {
      const { get } = await load(
        "https://cdn.jsdelivr.net/gh/kirakiray/NoneOS@1.3.2/core/fs/main.js"
      );

      //   const { minify } = await load(
      //     "https://cdn.jsdelivr.net/npm/html-minifier-terser@7.2.0/dist/htmlminifier.esm.bundle.js"
      //   );

      const { minify } = await load("../libs/htmlminifier.esm.fixed.js");

      return {
        data: {
          doing: false,
          tips: "",
          errors: [],
          ok: false,
        },
        proto: {
          async toSameDir(type) {
            if (type === "cover") {
              if (
                !confirm("此操作不可撤销，请备份好你的源文件，是否覆盖源文件？")
              ) {
                return;
              }
            }

            const { handles, compFiles, jsFiles, cssFiles, pageFiles } =
              this._data;

            const errors = [];

            await Promise.all(
              //   [...compFiles, ...pageFiles, ...jsFiles, ...cssFiles].map(
              [...cssFiles].map(async (path) => {
                const handle = handles.get(path);

                let content = await handle.text();

                if (/\.js$/.test(path)) {
                  content = `\x3Cscript>${content}\x3C\/script>`;
                } else if (/\.css/.test(path)) {
                  content = `\x3Cstyle>${content}\x3C\/style>`;
                }

                let result;

                try {
                  result = await minify(content, {
                    minifyCSS: true,
                    minifyJS: true,
                    removeComments: true,
                    collapseWhitespace: true,
                  });
                } catch (err) {
                  errors.push(path);
                  return;
                }

                if (/\.js$/.test(path)) {
                  result = result.replace(
                    /^\x3Cscript>([\s\S]+)\x3C\/script>/,
                    "$1"
                  );
                } else if (/\.css/.test(path)) {
                  result = result.replace(
                    /^\x3Cstyle>([\s\S]+)\x3C\/style>/,
                    "$1"
                  );
                }

                const parent = await handle.parent();

                const targetFile = await parent.get(
                  type === "cover"
                    ? handle.name.replace(/(.+)\.(.+)/, "$1.$2")
                    : handle.name.replace(/(.+)\.(.+)/, "$1.min.$2"),
                  {
                    create: "file",
                  }
                );

                await targetFile.write(result);
              })
            );

            this.ok = true;
            this.errors = errors;
          },
          //   async trans() {
          //     const { handles, compFiles, jsFiles, pageFiles } = this._data;

          //     const tempFolder = await get("__temp_folder", {
          //       create: "directory",
          //     });

          //     debugger;

          //     await Promise.all(
          //       jsFiles.map(async (path) => {
          //         const handle = handles.get(path);

          //         const content = await handle.text();

          //         const result = await Terser.minify(content);

          //         debugger;
          //       })
          //     );
          //   },
          //   async toDist() {
          //     this.doing = true;
          //     const datas = await this.trans();
          //     this.doing = false;
          //   },
          //   async toZip() {
          //     this.doing = true;
          //     const datas = await this.trans();
          //     this.doing = false;
          //   },
        },
        // attached() {
        //   setTimeout(() => {
        //     console.log(this._data);
        //   }, 500);
        // },
      };
    };
  </script>
</template>
